[package]
name = "micro-bpf"
version = "0.1.0"
edition = "2018"
resolver = "2"

[lib]
crate-type = ["staticlib"]

[profile.release]
# This is a typical set of options that helps Rust binaries stay small
panic = "abort"
lto = true
codegen-units = 1
opt-level = "s"

[features]
libud = []

[dependencies]
riot-wrappers = { version = "^0.9.0", features = [
    "set_panic_handler",
    "panic_handler_format",
    "provide_critical_section_1_0",
] }
riot-sys = { version = "0.7.10" }

portable-atomic = { version = "1", features = ["critical-section"] }

rbpf = { path = "../external/vm", default-features = false }
micro-bpf-common = { path = "../external/tools/common" }
micro-bpf-elf-utils = { path = "../external/tools/elf-utils" }
macros = { path = "../external/tools/macros" }
num = { version = "0.4.2", default-features = false }
num-derive = { version = "0.4.2", default-features = false }
num-traits = { version = "0.2.18", default-features = false }
log = "0.4.20"
# While currently this exmple does not use any RIOT modules implemented in
# Rust, that may change; it is best practice for any RIOT application that has
# its own top-level Rust crate to include rust_riotmodules from inside
# RIOTBASE.
rust_riotmodules = { path = "../RIOT/sys/rust_riotmodules/" }
static_cell = "2.1.0"

[patch.crates-io]
# from https://github.com/seanmonstar/try-lock/pull/11, necessary for those
# platforms without atomics (which also needs provide_critical_section_1_0 from
# riot-wrappers, and portable-atomic/critical-section to bridge the gap)
try-lock = { git = "https://github.com/seanmonstar/try-lock", rev = "45c39685b56a4dba1b71bdbbbe5f731c3c77dc50" }
